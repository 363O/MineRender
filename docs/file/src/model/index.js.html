<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/model/index.js | MineRender</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Documentation for MineRender, quick, easy, interactive Minecraft renders"><meta property="og:type" content="website"><meta property="og:url" content="https://minerender.org"><meta property="og:site_name" content="MineRender"><meta property="og:title" content="MineRender"><meta property="og:image" content="https://minerender.org/img/minerender-x256.png"><meta property="og:description" content="Documentation for MineRender, quick, easy, interactive Minecraft renders"><meta property="og:author" content="inventivetalent"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="MineRender"><meta property="twitter:description" content="Documentation for MineRender, quick, easy, interactive Minecraft renders"><meta property="twitter:image" content="https://minerender.org/img/minerender-x256.png"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./" style="display: flex; align-items: center;"><img src="./image/brand_logo.png" style="width:34px;"></a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/InventivetalentDev/MineRender"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/renderBase.js~Render.html">Render</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-loadBlockState">loadBlockState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-loadJsonFromPath">loadJsonFromPath</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-loadTextureAsBase64">loadTextureAsBase64</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-loadTextureMeta">loadTextureMeta</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-scaleUv">scaleUv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-trimCanvas">trimCanvas</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-deepDisposeMesh">deepDisposeMesh</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-mergeCubeMeshes">mergeCubeMeshes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-mergeMeshes__">mergeMeshes__</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DEFAULT_ROOT">DEFAULT_ROOT</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-defaultOptions">defaultOptions</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#combined">combined</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/combined/index.js~CombinedRender.html">CombinedRender</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#entity">entity</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/entity/index.js~EntityRender.html">EntityRender</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#gui">gui</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/gui/index.js~GuiRender.html">GuiRender</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-guiHelper">guiHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-guiPositions">guiPositions</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#lib">lib</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-OrbitControls">OrbitControls</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#model">model</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/index.js~ModelRender.html">ModelRender</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-worker">worker</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-ModelConverter">ModelConverter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-deleteObjectProperties">deleteObjectProperties</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-findMatchingVariant">findMatchingVariant</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-loadAndMergeModel">loadAndMergeModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-loadModel">loadModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-loadTextures">loadTextures</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-mergeParents">mergeParents</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-modelCacheKey">modelCacheKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseModel">parseModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseModelType">parseModelType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-toRadians">toRadians</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-variantStringToObject">variantStringToObject</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#skin">skin</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/skin/index.js~SkinRender.html">SkinRender</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-texturePositions">texturePositions</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/model/index.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import * as THREE from &quot;three&quot;;

require(&quot;three-instanced-mesh&quot;)(THREE);
import * as $ from &apos;jquery&apos;;
import merge from &apos;deepmerge&apos;
import Render, { defaultOptions, deepDisposeMesh, mergeCubeMeshes } from &quot;../renderBase&quot;;
import { loadTextureAsBase64, scaleUv, DEFAULT_ROOT, loadJsonFromPath, loadBlockState, loadTextureMeta } from &quot;../functions&quot;;
import ModelConverter from &quot;./modelConverter&quot;;
import * as md5 from &quot;md5&quot;;

import { parseModel, loadAndMergeModel, loadModelTexture, modelCacheKey, toRadians, deleteObjectProperties, loadTextures } from &quot;./modelFunctions&quot;;

import work from &apos;webworkify-webpack&apos;;
import SkinRender from &quot;../skin&quot;;
const ModelWorker = require.resolve(&quot;./ModelWorker.js&quot;);


String.prototype.replaceAll = function (search, replacement) {
    let target = this;
    return target.replace(new RegExp(search, &apos;g&apos;), replacement);
};

const colors = [
    0xFF0000,
    0x00FFFF,
    0x0000FF,
    0x000080,
    0xFF00FF,
    0x800080,
    0x808000,
    0x00FF00,
    0x008000,
    0xFFFF00,
    0x800000,
    0x008080,
];

const FACE_ORDER = [&quot;east&quot;, &quot;west&quot;, &quot;up&quot;, &quot;down&quot;, &quot;south&quot;, &quot;north&quot;];
const TINTS = [&quot;lightgreen&quot;];

const mergedModelCache = {};
const loadedTextureCache = {};
const modelInstances = {};

const textureCache = {};
const canvasCache = {};
const materialCache = {};
const geometryCache = {};
const instanceCache = {};

const animatedTextures = [];

/**
 * @see defaultOptions
 * @property {string} type alternative way to specify the model type (block/item)
 * @property {boolean} [centerCubes=false] center the cube&apos;s rotation point
 * @property {string} [assetRoot=DEFAULT_ROOT] root to get asset files from
 */
let defOptions = {
    camera: {
        type: &quot;perspective&quot;,
        x: 35,
        y: 25,
        z: 20,
        target: [0, 0, 0]
    },
    type: &quot;block&quot;,
    centerCubes: false,
    assetRoot: DEFAULT_ROOT,
    useWebWorkers: false
};

/**
 * A renderer for Minecraft models, i.e. blocks &amp; items
 */
class ModelRender extends Render {

    /**
     * @param {Object} [options] The options for this renderer, see {@link defaultOptions}
     * @param {string} [options.assetRoot=DEFAULT_ROOT] root to get asset files from
     *
     * @param {HTMLElement} [element=document.body] DOM Element to attach the renderer to - defaults to document.body
     * @constructor
     */
    constructor(options, element) {
        super(options, defOptions, element);

        this.renderType = &quot;ModelRender&quot;;

        this.models = [];
        this.attached = false;
    }

    /**
     * Does the actual rendering
     * @param {(string[]|Object[])} models Array of models to render - Either strings in the format &lt;block|item&gt;/&lt;model name&gt; or objects
     * @param {string} [models[].type=block] either &apos;block&apos; or &apos;item&apos;
     * @param {string} models[].model if &apos;type&apos; is given, just the block/item name otherwise &apos;&lt;block|item&gt;/&lt;model name&gt;&apos;
     * @param {number[]} [models[].offset] [x,y,z] array of the offset
     * @param {number[]} [models[].rotation] [x,y,z] array of the rotation
     * @param {string} [models[].blockstate] name of a blockstate to be used to determine the models (only for blocks)
     * @param {string} [models[].variant=normal] if &apos;blockstate&apos; is given, the block variant to use
     * @param {function} [cb] Callback when rendering finished
     */
    render(models, cb) {
        let modelRender = this;

        if (!modelRender.attached &amp;&amp; !modelRender._scene) {// Don&apos;t init scene if attached, since we already have an available scene
            super.initScene(function () {
                // Animate textures
                for (let i = 0; i &lt; animatedTextures.length; i++) {
                    animatedTextures[i]();
                }

                modelRender.element.dispatchEvent(new CustomEvent(&quot;modelRender&quot;, {detail: {models: modelRender.models}}));
            });
        } else {
            console.log(&quot;[ModelRender] is attached - skipping scene init&quot;);
        }

        let parsedModelList = [];

        parseModels(modelRender, models, parsedModelList)
            .then(() =&gt; loadAndMergeModels(modelRender, parsedModelList))
            .then(() =&gt; loadModelTextures(modelRender, parsedModelList))
            .then(() =&gt; doModelRender(modelRender, parsedModelList))
            .then((renderedModels) =&gt; {
                console.timeEnd(&quot;doModelRender&quot;);
                console.debug(renderedModels)
                if (typeof cb === &quot;function&quot;) cb();
            })

    }

}


function parseModels(modelRender, models, parsedModelList) {
    console.time(&quot;parseModels&quot;);
    console.log(&quot;Parsing Models...&quot;);
    let parsePromises = [];
    for (let i = 0; i &lt; models.length; i++) {
        let model = models[i];

        // parsePromises.push(parseModel(model, model, parsedModelList, modelRender.options.assetRoot))
        parsePromises.push(new Promise(resolve =&gt; {
            if(modelRender.options.useWebWorkers) {
                let w = work(ModelWorker);
                w.addEventListener(&apos;message&apos;, event =&gt; {
                    parsedModelList.push(...event.data.parsedModelList);
                    resolve();
                });
                w.postMessage({
                    func: &quot;parseModel&quot;,
                    model: model,
                    modelOptions: model,
                    parsedModelList: parsedModelList,
                    assetRoot: modelRender.options.assetRoot
                })
            }else{
                parseModel(model, model, parsedModelList, modelRender.options.assetRoot).then(()=&gt;{
                    resolve();
                })
            }
        }))

    }

    return Promise.all(parsePromises);
}


function loadAndMergeModels(modelRender, parsedModelList) {
    console.timeEnd(&quot;parseModels&quot;);
    console.time(&quot;loadAndMergeModels&quot;);

    let jsonPromises = [];

    console.log(&quot;Loading Model JSON data &amp; merging...&quot;);
    let uniqueModels = {};
    for (let i = 0; i &lt; parsedModelList.length; i++) {
        let cacheKey = modelCacheKey(parsedModelList[i]);
        modelInstances[cacheKey] = (modelInstances[cacheKey] || 0) + 1;
        uniqueModels[cacheKey] = parsedModelList[i];
    }
    let uniqueModelList = Object.values(uniqueModels);
    console.debug(uniqueModelList.length + &quot; unique models&quot;);
    for (let i = 0; i &lt; uniqueModelList.length; i++) {
        jsonPromises.push(new Promise(resolve =&gt; {
            let model = uniqueModelList[i];
            let cacheKey = modelCacheKey(model);
            console.debug(&quot;loadAndMerge &quot; + cacheKey);



            if (mergedModelCache.hasOwnProperty(cacheKey)) {
                resolve();
                return;
            }

            if(modelRender.options.useWebWorkers) {
                let w = work(ModelWorker);
                w.addEventListener(&apos;message&apos;, event =&gt; {
                    mergedModelCache[cacheKey] = event.data.mergedModel;
                    resolve();
                });
                w.postMessage({
                    func: &quot;loadAndMergeModel&quot;,
                    model: model,
                    assetRoot: modelRender.options.assetRoot
                });
            }else{
                loadAndMergeModel(model,modelRender.options.assetRoot).then((mergedModel)=&gt;{
                    mergedModelCache[cacheKey] = mergedModel;
                    resolve();
                })
            }
        }))
    }

    return Promise.all(jsonPromises);
}

function loadModelTextures(modelRender, parsedModelList) {
    console.timeEnd(&quot;loadAndMergeModels&quot;);
    console.time(&quot;loadModelTextures&quot;);

    let texturePromises = [];

    console.log(&quot;Loading Textures...&quot;);
    let uniqueModels = {};
    for (let i = 0; i &lt; parsedModelList.length; i++) {
        uniqueModels[modelCacheKey(parsedModelList[i])] = parsedModelList[i];
    }
    let uniqueModelList = Object.values(uniqueModels);
    console.debug(uniqueModelList.length + &quot; unique models&quot;);
    for (let i = 0; i &lt; uniqueModelList.length; i++) {
        texturePromises.push(new Promise(resolve =&gt; {
            let model = uniqueModelList[i];
            let cacheKey = modelCacheKey(model);
            console.debug(&quot;loadTexture &quot; + cacheKey);
            let mergedModel = mergedModelCache[cacheKey];

            if (loadedTextureCache.hasOwnProperty(cacheKey)) {
                resolve();
                return;
            }

            if (!mergedModel) {
                console.warn(&quot;Missing merged model&quot;);
                console.warn(model.name);
                resolve();
                return;
            }

            if (!mergedModel.textures) {
                console.warn(&quot;The model doesn&apos;t have any textures!&quot;);
                console.warn(&quot;Please make sure you&apos;re using the proper file.&quot;);
                console.warn(model.name);
                resolve();
                return;
            }

            if(modelRender.options.useWebWorkers) {
                let w = work(ModelWorker);
                w.addEventListener(&apos;message&apos;, event =&gt; {
                    loadedTextureCache[cacheKey] = event.data.textures;
                    resolve();
                });
                w.postMessage({
                    func: &quot;loadTextures&quot;,
                    textures: mergedModel.textures,
                    assetRoot: modelRender.options.assetRoot
                });
            }else{
                loadTextures(mergedModel.textures, modelRender.options.assetRoot).then((textures)=&gt;{
                    loadedTextureCache[cacheKey] = textures;
                    resolve();
                })
            }
        }))
    }


    return Promise.all(texturePromises);
}

function doModelRender(modelRender, parsedModelList) {
    console.timeEnd(&quot;loadModelTextures&quot;);
    console.time(&quot;doModelRender&quot;);

    console.log(&quot;Rendering Models...&quot;);

    let renderPromises = [];

    for (let i = 0; i &lt; parsedModelList.length; i++) {
        renderPromises.push(new Promise(resolve =&gt; {
            let model = parsedModelList[i];

            let mergedModel = mergedModelCache[modelCacheKey(model)];
            let textures = loadedTextureCache[modelCacheKey(model)];

            let offset = model.offset || [0, 0, 0];
            let rotation = model.rotation || [0, 0, 0];
            let scale = model.scale || [1, 1, 1];

            if (model.options.hasOwnProperty(&quot;display&quot;)) {
                if (mergedModel.hasOwnProperty(&quot;display&quot;)) {
                    if (mergedModel.display.hasOwnProperty(model.options.display)) {
                        let displayData = mergedModel.display[model.options.display];

                        if (displayData.hasOwnProperty(&quot;translation&quot;)) {
                            offset = [offset[0] + displayData.translation[0], offset[1] + displayData.translation[1], offset[2] + displayData.translation[2]];
                        }
                        if (displayData.hasOwnProperty(&quot;rotation&quot;)) {
                            rotation = [rotation[0] + displayData.rotation[0], rotation[1] + displayData.rotation[1], rotation[2] + displayData.rotation[2]];
                        }
                        if (displayData.hasOwnProperty(&quot;scale&quot;)) {
                            scale = [displayData.scale[0], displayData.scale[1], displayData.scale[2]];
                        }

                    }
                }
            }


            renderModel(modelRender, mergedModel, textures, mergedModel.textures, model.type, model.name, model.variant, offset, rotation, scale).then((renderedModel) =&gt; {

                if (renderedModel.firstInstance) {
                    let container = new THREE.Object3D();
                    container.add(renderedModel.mesh);

                    modelRender.models.push(container);
                    modelRender.addToScene(container);
                }

                resolve(renderedModel);
            })
        }))
    }

    return Promise.all(renderPromises);
}


let renderModel = function (modelRender, model, textures, textureNames, type, name, variant, offset, rotation, scale) {
    return new Promise((resolve) =&gt; {
        if (model.hasOwnProperty(&quot;elements&quot;)) {// block OR item with block parent
            let modelKey = modelCacheKey({type: type, name: name, variant: variant});
            let instanceCount = modelInstances[modelKey];

            let applyModelTransforms = function (mesh, instanceIndex) {
                mesh.userData.modelType = type;
                mesh.userData.modelName = name;

                let _v3o = new THREE.Vector3();
                let _v3s = new THREE.Vector3();
                let _q = new THREE.Quaternion();

                if (rotation) {
                    mesh.setQuaternionAt(instanceIndex, _q.setFromEuler(new THREE.Euler(toRadians(rotation[0]), toRadians(Math.abs(rotation[0]) &gt; 0 ? rotation[1] : -rotation[1]), toRadians(rotation[2]))));
                }
                if (offset) {
                    mesh.setPositionAt(instanceIndex, _v3o.set(offset[0], offset[1], offset[2]));
                }
                if (scale) {
                    mesh.setScaleAt(instanceIndex, _v3s.set(scale[0], scale[1], scale[2]));
                }

                mesh.needsUpdate();

                // mesh.position = _v3o;
                // Object.defineProperty(mesh.position,&quot;x&quot;,{
                //     get:function () {
                //         return this._x||0;
                //     },
                //     set:function (x) {
                //         this._x=x;
                //         mesh.setPositionAt(instanceIndex, _v3o.set(x, this.y, this.z));
                //     }
                // });
                // Object.defineProperty(mesh.position,&quot;y&quot;,{
                //     get:function () {
                //         return this._y||0;
                //     },
                //     set:function (y) {
                //         this._y=y;
                //         mesh.setPositionAt(instanceIndex, _v3o.set(this.x, y, this.z));
                //     }
                // });
                // Object.defineProperty(mesh.position,&quot;z&quot;,{
                //     get:function () {
                //         return this._z||0;
                //     },
                //     set:function (z) {
                //         this._z=z;
                //         mesh.setPositionAt(instanceIndex, _v3o.set(this.x, this.y, z));
                //     }
                // })
                //
                // mesh.rotation = new THREE.Euler(toRadians(rotation[0]), toRadians(Math.abs(rotation[0]) &gt; 0 ? rotation[1] : -rotation[1]), toRadians(rotation[2]));
                // Object.defineProperty(mesh.rotation,&quot;x&quot;,{
                //     get:function () {
                //         return this._x||0;
                //     },
                //     set:function (x) {
                //         this._x=x;
                //         mesh.setQuaternionAt(instanceIndex, _q.setFromEuler(new THREE.Euler(toRadians(x), toRadians(this.y), toRadians(this.z))));
                //     }
                // });
                // Object.defineProperty(mesh.rotation,&quot;y&quot;,{
                //     get:function () {
                //         return this._y||0;
                //     },
                //     set:function (y) {
                //         this._y=y;
                //         mesh.setQuaternionAt(instanceIndex, _q.setFromEuler(new THREE.Euler(toRadians(this.x), toRadians(y), toRadians(this.z))));
                //     }
                // });
                // Object.defineProperty(mesh.rotation,&quot;z&quot;,{
                //     get:function () {
                //         return this._z||0;
                //     },
                //     set:function (z) {
                //         this._z=z;
                //         mesh.setQuaternionAt(instanceIndex, _q.setFromEuler(new THREE.Euler(toRadians(this.x), toRadians(this.y), toRadians(z))));
                //     }
                // });
                //
                // mesh.scale = _v3s;

                resolve({
                    mesh: mesh,
                    firstInstance: instanceIndex === 0
                });
            };

            let finalizeCubeModel = function (geometry, materials) {
                geometry.translate(-8, -8, -8);


                let cachedInstance;

                if (!instanceCache.hasOwnProperty(modelKey)) {
                    console.debug(&quot;Caching new model instance &quot; + modelKey + &quot; (with &quot; + instanceCount + &quot; instances)&quot;);
                    let newInstance = new THREE.InstancedMesh(
                        geometry,
                        materials,
                        instanceCount,
                        false,
                        false,
                        false);
                    cachedInstance = {
                        instance: newInstance,
                        index: 0
                    };
                    instanceCache[modelKey] = cachedInstance;
                    let _v3o = new THREE.Vector3();
                    let _v3s = new THREE.Vector3(1, 1, 1);
                    let _q = new THREE.Quaternion();

                    for (let i = 0; i &lt; instanceCount; i++) {

                        newInstance.setQuaternionAt(i, _q);
                        newInstance.setPositionAt(i, _v3o);
                        newInstance.setScaleAt(i, _v3s);

                    }
                } else {
                    console.debug(&quot;Using cached instance (&quot; + modelKey + &quot;)&quot;);
                    cachedInstance = instanceCache[modelKey];

                }

                applyModelTransforms(cachedInstance.instance, cachedInstance.index++);
            };

            if (instanceCache.hasOwnProperty(modelKey)) {
                console.debug(&quot;Using cached model instance (&quot; + modelKey + &quot;)&quot;);
                let cachedInstance = instanceCache[modelKey];
                applyModelTransforms(cachedInstance.instance, cachedInstance.index++);
                return;
            }

            // Render the elements
            let promises = [];
            for (let i = 0; i &lt; model.elements.length; i++) {
                let element = model.elements[i];

                // // From net.minecraft.client.renderer.block.model.BlockPart.java#47 - https://yeleha.co/2JcqSr4
                let fallbackFaces = {
                    down: {
                        uv: [element.from[0], 16 - element.to[2], element.to[0], 16 - element.from[2]],
                        texture: &quot;#down&quot;
                    },
                    up: {
                        uv: [element.from[0], element.from[2], element.to[0], element.to[2]],
                        texture: &quot;#up&quot;
                    },
                    north: {
                        uv: [16 - element.to[0], 16 - element.to[1], 16 - element.from[0], 16 - element.from[1]],
                        texture: &quot;#north&quot;
                    },
                    south: {
                        uv: [element.from[0], 16 - element.to[1], element.to[0], 16 - element.from[1]],
                        texture: &quot;#south&quot;
                    },
                    west: {
                        uv: [element.from[2], 16 - element.to[1], element.to[2], 16 - element.from[2]],
                        texture: &quot;#west&quot;
                    },
                    east: {
                        uv: [16 - element.to[2], 16 - element.to[1], 16 - element.from[2], 16 - element.from[1]],
                        texture: &quot;#east&quot;
                    }
                };

                promises.push(new Promise((resolve) =&gt; {
                    let baseName =name.replaceAll(&quot; &quot;, &quot;_&quot;).replaceAll(&quot;-&quot;, &quot;_&quot;).toLowerCase() + &quot;_&quot; + (element.__comment ? element.__comment.replaceAll(&quot; &quot;, &quot;_&quot;).replaceAll(&quot;-&quot;, &quot;_&quot;).toLowerCase() + &quot;_&quot; : &quot;&quot;);
                    createCube(element.to[0] - element.from[0], element.to[1] - element.from[1], element.to[2] - element.from[2],
                        baseName + Date.now(),
                        element.faces, fallbackFaces, textures, textureNames, modelRender.options.assetRoot, baseName)
                        .then((cube) =&gt; {
                            cube.applyMatrix(new THREE.Matrix4().makeTranslation((element.to[0] - element.from[0]) / 2, (element.to[1] - element.from[1]) / 2, (element.to[2] - element.from[2]) / 2));
                            cube.applyMatrix(new THREE.Matrix4().makeTranslation(element.from[0], element.from[1], element.from[2]));

                            if (element.rotation) {
                                rotateAboutPoint(cube,
                                    new THREE.Vector3(element.rotation.origin[0], element.rotation.origin[1], element.rotation.origin[2]),
                                    new THREE.Vector3(element.rotation.axis === &quot;x&quot; ? 1 : 0, element.rotation.axis === &quot;y&quot; ? 1 : 0, element.rotation.axis === &quot;z&quot; ? 1 : 0),
                                    toRadians(element.rotation.angle));
                            }

                            resolve(cube);
                        })
                }));


            }

            Promise.all(promises).then((cubes) =&gt; {
                let mergedCubes = mergeCubeMeshes(cubes, true);
                mergedCubes.sourceSize = cubes.length;
                finalizeCubeModel(mergedCubes.geometry, mergedCubes.materials, cubes.length);
                for (let i = 0; i &lt; cubes.length; i++) {
                    deepDisposeMesh(cubes[i], true);
                }
            })
        } else {// 2d item
            createPlane(name + &quot;_&quot; + Date.now(), textures).then((plane) =&gt; {
                if (offset) {
                    plane.applyMatrix(new THREE.Matrix4().makeTranslation(offset[0], offset[1], offset[2]))
                }
                if (rotation) {
                    plane.rotation.set(toRadians(rotation[0]), toRadians(Math.abs(rotation[0]) &gt; 0 ? rotation[1] : -rotation[1]), toRadians(rotation[2]));
                }
                if (scale) {
                    plane.scale.set(scale[0], scale[1], scale[2]);
                }

                resolve({
                    mesh: plane,
                    firstInstance: true
                });
            })
        }
    })
};

let createDot = function (c) {
    let dotGeometry = new THREE.Geometry();
    dotGeometry.vertices.push(new THREE.Vector3());
    let dotMaterial = new THREE.PointsMaterial({size: 5, sizeAttenuation: false, color: c});
    return new THREE.Points(dotGeometry, dotMaterial);
};

let createPlane = function (name, textures) {
    return new Promise((resolve) =&gt; {

        let materialLoaded = function (material, width, height) {
            let geometry = new THREE.PlaneGeometry(width, height);
            let plane = new THREE.Mesh(geometry, material);
            plane.name = name;
            plane.receiveShadow = true;

            resolve(plane);
        };

        if (textures) {
            let w = 0, h = 0;
            let promises = [];
            for (let t in textures) {
                if (textures.hasOwnProperty(t)) {
                    promises.push(new Promise((resolve) =&gt; {
                        let img = new Image();
                        img.onload = function () {
                            if (img.width &gt; w) w = img.width;
                            if (img.height &gt; h) h = img.height;
                            resolve(img);
                        };
                        img.src = textures[t];
                    }))
                }
            }
            Promise.all(promises).then((images) =&gt; {
                let canvas = document.createElement(&quot;canvas&quot;);
                canvas.width = w;
                canvas.height = h;
                let context = canvas.getContext(&quot;2d&quot;);

                for (let i = 0; i &lt; images.length; i++) {
                    let img = images[i];
                    context.drawImage(img, 0, 0);
                }

                let data = canvas.toDataURL(&quot;image/png&quot;);
                let hash = md5(data);

                if (materialCache.hasOwnProperty(hash)) {// Use material from cache
                    console.debug(&quot;Using cached Material (&quot; + hash + &quot;)&quot;);
                    materialLoaded(materialCache[hash], w, h);
                    return;
                }

                let textureLoaded = function (texture) {
                    let material = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        side: THREE.DoubleSide,
                        alphaTest: 0.5,
                        name: name
                    });

                    // Add material to cache
                    console.debug(&quot;Caching Material &quot; + hash);
                    materialCache[hash] = material;

                    materialLoaded(material, w, h);
                };

                if (textureCache.hasOwnProperty(hash)) {// Use texture to cache
                    console.debug(&quot;Using cached Texture (&quot; + hash + &quot;)&quot;);
                    textureLoaded(textureCache[hash]);
                    return;
                }

                console.debug(&quot;Pre-Caching Texture &quot; + hash);
                textureCache[hash] = new THREE.TextureLoader().load(data, function (texture) {
                    texture.magFilter = THREE.NearestFilter;
                    texture.minFilter = THREE.NearestFilter;
                    texture.anisotropy = 0;
                    texture.needsUpdate = true;

                    console.debug(&quot;Caching Texture &quot; + hash);
                    // Add texture to cache
                    textureCache[hash] = texture;

                    textureLoaded(texture);
                });
            });
        }

    })
};


/// From https://github.com/InventivetalentDev/SkinRender/blob/master/js/render/skin.js#L353
let createCube = function (width, height, depth, name, faces, fallbackFaces, textures, textureNames, assetRoot, baseName) {
    return new Promise((resolve) =&gt; {
        let geometryKey = width + &quot;_&quot; + height + &quot;_&quot; + depth;
        let geometry;
        if (geometryCache.hasOwnProperty(geometryKey)) {
            console.debug(&quot;Using cached Geometry (&quot; + geometryKey + &quot;)&quot;);
            geometry = geometryCache[geometryKey];
        } else {
            geometry = new THREE.BoxGeometry(width, height, depth);
            console.debug(&quot;Caching Geometry &quot; + geometryKey);
            geometryCache[geometryKey] = geometry;
        }

        let materialsLoaded = function (materials) {
            let cube = new THREE.Mesh(geometry, materials);
            cube.name = name;
            cube.receiveShadow = true;

            resolve(cube);
        };
        if (textures) {
            let promises = [];
            for (let i = 0; i &lt; 6; i++) {
                promises.push(new Promise((resolve) =&gt; {
                    let f = FACE_ORDER[i];
                    if (!faces.hasOwnProperty(f)) {
                        // console.warn(&quot;Missing face: &quot; + f + &quot; in model &quot; + name);
                        resolve(null);
                        return;
                    }
                    let face = faces[f];
                    let textureRef = face.texture.substr(1);
                    if (!textures.hasOwnProperty(textureRef)) {
                        console.warn(&quot;Missing texture &apos;&quot; + textureRef + &quot;&apos; for face &quot; + f + &quot; in model &quot; + name);
                        resolve(null);
                        return;
                    }

                    let canvasKey = textureRef + &quot;_&quot; + f + &quot;_&quot; + baseName;

                    let processImgToCanvasData = (img)=&gt;{
                        let uv = face.uv;
                        if (!uv) {
                            // console.warn(&quot;Missing UV mapping for face &quot; + f + &quot; in model &quot; + name + &quot;. Using defaults&quot;);
                            uv = fallbackFaces[f].uv;
                        }

                        // Scale the uv values to match the image width, so we can support resource packs with higher-resolution textures
                        uv = [
                            scaleUv(uv[0], img.width),
                            scaleUv(uv[1], img.height),
                            scaleUv(uv[2], img.width),
                            scaleUv(uv[3], img.height)
                        ];


                        let canvas = document.createElement(&quot;canvas&quot;);
                        canvas.width = Math.abs(uv[2] - uv[0]);
                        canvas.height = Math.abs(uv[3] - uv[1]);

                        let context = canvas.getContext(&quot;2d&quot;);
                        context.drawImage(img, Math.min(uv[0], uv[2]), Math.min(uv[1], uv[3]), canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);

                        if (face.hasOwnProperty(&quot;tintindex&quot;)) {
                            context.fillStyle = TINTS[face.tintindex];
                            context.globalCompositeOperation = &apos;multiply&apos;;
                            context.fillRect(0, 0, canvas.width, canvas.height);

                            context.globalAlpha = 1;
                            context.globalCompositeOperation = &apos;destination-in&apos;;
                            context.drawImage(img, Math.min(uv[0], uv[2]), Math.min(uv[1], uv[3]), canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);

                            // context.globalAlpha = 0.5;
                            // context.beginPath();
                            // context.fillStyle = &quot;green&quot;;
                            // context.rect(0, 0, uv[2] - uv[0], uv[3] - uv[1]);
                            // context.fill();
                            // context.globalAlpha = 1.0;
                        }

                        let canvasData = context.getImageData(0, 0, canvas.width, canvas.height).data;
                        let hasTransparency = false;
                        for (let i = 3; i &lt; (canvas.width * canvas.height); i += 4) {
                            if (canvasData[i] &lt; 255) {
                                hasTransparency = true;
                                break;
                            }
                        }

                        let dataUrl =  canvas.toDataURL(&quot;image/png&quot;);
                        let dataHash = md5(dataUrl);

                        let d = {
                            data: canvasData,
                            dataUrl: dataUrl,
                            dataUrlHash: dataHash,
                            hasTransparency: hasTransparency,
                            width: canvas.width,
                            height: canvas.height
                        };
                        console.debug(&quot;Caching new canvas (&quot;+canvasKey+&quot;/&quot;+dataHash+&quot;)&quot;)
                        canvasCache[canvasKey] = d;
                        return d;
                    };

                    let loadTextureFromCanvas = (canvas)=&gt;{


                        let loadTextureDefault = function (canvas) {
                            let data = canvas.dataUrl;
                            let hash =canvas.dataUrlHash;
                            let hasTransparency = canvas.hasTransparency;

                            if (materialCache.hasOwnProperty(hash)) {// Use material from cache
                                console.debug(&quot;Using cached Material (&quot; + hash + &quot;)&quot;);
                                resolve(materialCache[hash]);
                                return;
                            }

                            let textureLoaded = function (texture) {
                                let n = textureNames[textureRef];
                                if (n.startsWith(&quot;#&quot;)) {
                                    n = textureNames[name.substr(1)];
                                }

                                let material = new THREE.MeshBasicMaterial({
                                    map: texture,
                                    transparent: hasTransparency,
                                    side: hasTransparency ? THREE.DoubleSide : THREE.FrontSide,
                                    alphaTest: 0.5,
                                    name: f + &quot;_&quot; + textureRef + &quot;_&quot; + n
                                });

                                // Add material to cache
                                console.debug(&quot;Caching Material &quot; + hash);
                                materialCache[hash] = material;

                                resolve(material);
                            };

                            if (textureCache.hasOwnProperty(hash)) {// Use texture from cache
                                console.debug(&quot;Using cached Texture (&quot; + hash + &quot;)&quot;);
                                textureLoaded(textureCache[hash]);
                                return;
                            }

                            console.debug(&quot;Pre-Caching Texture &quot; + hash);
                            textureCache[hash] = new THREE.TextureLoader().load(data, function (texture) {
                                texture.magFilter = THREE.NearestFilter;
                                texture.minFilter = THREE.NearestFilter;
                                texture.anisotropy = 0;
                                texture.needsUpdate = true;

                                if (face.hasOwnProperty(&quot;rotation&quot;)) {
                                    texture.center.x = .5;
                                    texture.center.y = .5;
                                    texture.rotation = toRadians(face.rotation);
                                }

                                console.debug(&quot;Caching Texture &quot; + hash);
                                // Add texture to cache
                                textureCache[hash] = texture;

                                textureLoaded(texture);
                            });
                        };

                        let loadTextureWithMeta = function (canvas, meta) {
                            let hasTransparency = canvas.hasTransparency;
                            let frametime = 1;
                            if (meta.hasOwnProperty(&quot;animation&quot;)) {
                                if (meta.animation.hasOwnProperty(&quot;frametime&quot;)) {
                                    frametime = meta.animation.frametime;
                                }
                            }

                            let parts = Math.floor(canvas.height / canvas.width);

                            let promises1 = [];
                            for (let i = 0; i &lt; parts; i++) {
                                promises1.push(new Promise((resolve) =&gt; {
                                    let canvas1 = document.createElement(&quot;canvas&quot;);
                                    canvas1.width = canvas.width;
                                    canvas1.height = canvas.width;
                                    let context1 = canvas1.getContext(&quot;2d&quot;);
                                    context1.drawImage(canvas, 0, i * canvas.width, canvas.width, canvas.width, 0, 0, canvas.width, canvas.width);

                                    let data = canvas1.toDataURL(&quot;image/png&quot;);
                                    let hash = md5(data);

                                    if (textureCache.hasOwnProperty(hash)) {// Use texture to cache
                                        console.debug(&quot;Using cached Texture (&quot; + hash + &quot;)&quot;);
                                        resolve(textureCache[hash]);
                                        return;
                                    }

                                    console.debug(&quot;Pre-Caching Texture &quot; + hash);
                                    textureCache[hash] = new THREE.TextureLoader().load(data, function (texture) {
                                        texture.magFilter = THREE.NearestFilter;
                                        texture.minFilter = THREE.NearestFilter;
                                        texture.anisotropy = 0;
                                        texture.needsUpdate = true;

                                        console.debug(&quot;Caching Texture &quot; + hash);
                                        // add texture to cache
                                        textureCache[hash] = texture;

                                        resolve(texture);
                                    });
                                }));
                            }

                            Promise.all(promises1).then((textures) =&gt; {

                                // Don&apos;t cache this material, since it&apos;s animated
                                let material = new THREE.MeshBasicMaterial({
                                    map: textures[0],
                                    transparent: hasTransparency,
                                    side: hasTransparency ? THREE.DoubleSide : THREE.FrontSide,
                                    alphaTest: 0.5
                                });

                                let frameCounter = 0;
                                let textureIndex = 0;
                                animatedTextures.push(() =&gt; {// called on render
                                    if (frameCounter &gt;= frametime) {
                                        frameCounter = 0;

                                        // Set new texture
                                        material.map = textures[textureIndex];

                                        textureIndex++;
                                    }
                                    if (textureIndex &gt;= textures.length) {
                                        textureIndex = 0;
                                    }
                                    frameCounter += 0.1;// game ticks TODO: figure out the proper value for this
                                })

                                resolve(material);
                            });
                        };

                        if ((canvas.height &gt; canvas.width) &amp;&amp; (canvas.height % canvas.width === 0)) {// Taking a guess that this is an animated texture
                            let name = textureNames[textureRef];
                            if (name.startsWith(&quot;#&quot;)) {
                                name = textureNames[name.substr(1)];
                            }
                            if (name.indexOf(&quot;/&quot;) !== -1) {
                                name = name.substr(name.indexOf(&quot;/&quot;) + 1);
                            }
                            loadTextureMeta(name, assetRoot).then((meta) =&gt; {
                                loadTextureWithMeta(canvas, meta);
                            }).catch(() =&gt; {// Guessed wrong :shrug:
                                loadTextureDefault(canvas);
                            })
                        } else {
                            loadTextureDefault(canvas);
                        }
                    };


                    if (canvasCache.hasOwnProperty(canvasKey)) {
                        let cachedCanvas = canvasCache[canvasKey];

                        if (cachedCanvas.hasOwnProperty(&quot;img&quot;)) {
                            console.debug(&quot;Waiting for canvas image that&apos;s already loading (&quot;+canvasKey+&quot;)&quot;)
                           let img= cachedCanvas.img;
                           img.waitingForCanvas.push(function (canvas) {
                               loadTextureFromCanvas(canvas);
                           });
                        } else {
                            console.debug(&quot;Using cached canvas (&quot; + canvasKey + &quot;)&quot;)
                            loadTextureFromCanvas(canvasCache[canvasKey]);
                        }
                    } else {
                        let img = new Image();
                        img.onerror = function (err) {
                            console.warn(err);
                            resolve(null);
                        };
                        img.waitingForCanvas = [];
                        img.onload = function () {
                            let canvasData = processImgToCanvasData(img);
                            loadTextureFromCanvas(canvasData);

                            for (let c = 0; c &lt; img.waitingForCanvas.length; c++) {
                                img.waitingForCanvas[c](canvasData);
                            }
                        };
                        console.debug(&quot;Pre-caching canvas (&quot; + canvasKey + &quot;)&quot;);
                        canvasCache[canvasKey] = {
                            img: img
                        };
                        img.src = textures[textureRef];
                    }
                }));
            }
            Promise.all(promises).then(materials =&gt; materialsLoaded(materials))
        } else {
            let materials = [];
            for (let i = 0; i &lt; 6; i++) {
                materials.push(new THREE.MeshBasicMaterial({
                    color: colors[i + 2],
                    wireframe: true
                }))
            }
            materialsLoaded(materials);
        }

        // if (textures) {
        //     applyCubeTextureToGeometry(geometry, texture, uv, width, height, depth);
        // }


    })
};

/// https://stackoverflow.com/questions/42812861/three-js-pivot-point/42866733#42866733
// obj - your object (THREE.Object3D or derived)
// point - the point of rotation (THREE.Vector3)
// axis - the axis of rotation (normalized THREE.Vector3)
// theta - radian value of rotation
function rotateAboutPoint(obj, point, axis, theta) {
    obj.position.sub(point); // remove the offset
    obj.position.applyAxisAngle(axis, theta); // rotate the POSITION
    obj.position.add(point); // re-add the offset

    obj.rotateOnAxis(axis, theta); // rotate the OBJECT
}

ModelRender.cache = {
    loadedTextures: loadedTextureCache,
    mergedModels: mergedModelCache,
    instanceCount: modelInstances,

    texture: textureCache,
    canvas: canvasCache,
    material: materialCache,
    geometry: geometryCache,
    instances: instanceCache,


    resetInstances: function () {
        deleteObjectProperties(modelInstances);
        deleteObjectProperties(instanceCache);
    },
    clearAll: function () {
        deleteObjectProperties(loadedTextureCache);
        deleteObjectProperties(mergedModelCache);
        deleteObjectProperties(modelInstances);
        deleteObjectProperties(textureCache);
        deleteObjectProperties(materialCache);
        deleteObjectProperties(geometryCache);
        deleteObjectProperties(instanceCache);
    }
};
ModelRender.ModelConverter = ModelConverter;

if (typeof window !== &quot;undefined&quot;) {
    window.ModelRender = ModelRender;
    window.ModelConverter = ModelConverter;
}
if (typeof global !== &quot;undefined&quot;)
    global.ModelRender = ModelRender;

export default ModelRender;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
